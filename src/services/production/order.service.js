import httpStatus from 'http-status';
import mongoose from 'mongoose';
import { ProductionOrder, Article, ArticleLog } from '../../models/production/index.js';
import Product from '../../models/product.model.js';
import ApiError from '../../utils/ApiError.js';
import { generateArticleNumber } from '../../utils/generateId.js';
import { getAllFloorsOrder, getFloorKey, validateProductProcesses } from '../../utils/productionHelper.js';
// import { generateOrderNumber } from '../../utils/generateId.js'; // Using model's auto-generation instead

/**
 * Create a production order
 * @param {Object} orderBody
 * @param {Object} user - Current user from request
 * @returns {Promise<ProductionOrder>}
 */
export const createProductionOrder = async (orderBody, user = null) => {
  // Set user fields if not provided
  if (!orderBody.createdBy && user) {
    orderBody.createdBy = user.id;
  }
  if (!orderBody.lastModifiedBy && user) {
    orderBody.lastModifiedBy = user.id;
  }

  // Order number will be auto-generated by the model's pre-save middleware
  // Remove orderNumber from orderBody to let the model handle it
  delete orderBody.orderNumber;

  // Validate product processes for each article before creating
  const validationErrors = [];
  for (const articleData of orderBody.articles) {
    const articleNumber = articleData.articleNumber;
    
    if (!articleNumber) {
      validationErrors.push(`Article missing articleNumber (factoryCode)`);
      continue;
    }

    // Find product by factoryCode (articleNumber = factoryCode)
    const product = await Product.findOne({ factoryCode: articleNumber })
      .populate('processes.processId');

    if (!product) {
      validationErrors.push(
        `Article ${articleNumber}: Product not found with factoryCode "${articleNumber}". ` +
        `Please ensure the product exists with matching factoryCode.`
      );
      continue;
    }

    // Validate product processes against available article floors
    const validation = validateProductProcesses(product.processes, articleNumber);
    
    if (!validation.valid) {
      validationErrors.push(...validation.errors);
    }
  }

  // If any validation errors, throw error and prevent order creation
  if (validationErrors.length > 0) {
    throw new ApiError(
      httpStatus.BAD_REQUEST,
      `Cannot create production order: Process validation failed.\n${validationErrors.join('\n')}`
    );
  }

  // Create articles with initial logs
  const articles = [];
  for (const articleData of orderBody.articles) {
    const article = new Article({
      ...articleData,
      id: await generateArticleNumber(), // Generate unique article ID
      currentFloor: 'Knitting',
      status: 'Pending',
      progress: 0,
      completedQuantity: 0,
      logs: []
    });
    articles.push(article);
  }

  // Create the order
  const order = new ProductionOrder({
    ...orderBody,
    articles: [],
    currentFloor: 'Knitting',
    status: 'Pending'
  });

  // Save order first to get ID and generate order number
  await order.save();

  // Update articles with order ID and save them
  for (let i = 0; i < articles.length; i++) {
    articles[i].orderId = order._id;
    await articles[i].save();
  }

  // Update order with article IDs
  order.articles = articles.map(article => article._id);
  await order.save();

  // Create initial logs for each article
  for (const article of articles) {
    await createArticleLog({
      articleId: article._id.toString(),
      orderId: order._id.toString(),
      action: 'Article Added',
      quantity: article.plannedQuantity,
      remarks: `Article ${article.articleNumber} added to order ${order.orderNumber}`,
      userId: orderBody.createdBy || user?.id || 'system',
      floorSupervisorId: orderBody.createdBy || user?.id || 'system'
    });
  }

  // Create order creation log
  await createArticleLog({
    orderId: order._id.toString(),
    action: 'Order Created',
    quantity: 0,
    remarks: `Order ${order.orderNumber} created with ${articles.length} articles`,
    userId: orderBody.createdBy || user?.id || 'system',
    floorSupervisorId: orderBody.createdBy || user?.id || 'system'
  });

  return order.populate({
    path: 'articles',
    populate: {
      path: 'machineId',
      select: 'machineCode machineNumber model floor status capacityPerShift capacityPerDay assignedSupervisor'
    }
  });
};

/**
 * Query for production orders
 * @param {Object} filter - Mongo filter
 * @param {Object} options - Query options
 * @returns {Promise<QueryResult>}
 */
export const queryProductionOrders = async (filter, options) => {
  // Handle search functionality
  if (filter.search) {
    const searchTerm = filter.search;
    delete filter.search; // Remove search from filter to avoid conflicts
    
    // First, search for orders by orderNumber
    const orderNumberQuery = { orderNumber: { $regex: searchTerm, $options: 'i' } };
    
    // Also search for articles with matching articleNumber and get their orderIds
    const matchingArticles = await Article.find(
      { articleNumber: { $regex: searchTerm, $options: 'i' } },
      { orderId: 1 }
    );
    
    const orderIds = matchingArticles.map(article => article.orderId);
    
    // Create search query combining both orderNumber and articleNumber searches
    const searchQuery = {
      $or: [
        orderNumberQuery,
        ...(orderIds.length > 0 ? [{ _id: { $in: orderIds } }] : [])
      ]
    };
    
    // Merge search query with existing filter
    const finalFilter = { ...filter, ...searchQuery };
    
    const orders = await ProductionOrder.paginate(finalFilter, {
      ...options,
      populate: {
        path: 'articles',
        populate: {
          path: 'machineId',
          select: 'machineCode machineNumber model floor status capacityPerShift capacityPerDay assignedSupervisor'
        }
      }
    });
    return orders;
  }
  
  const orders = await ProductionOrder.paginate(filter, {
    ...options,
    populate: {
      path: 'articles',
      populate: {
        path: 'machineId',
        select: 'machineCode machineNumber model floor status capacityPerShift capacityPerDay assignedSupervisor'
      }
    }
  });
  return orders;
};

/**
 * Get production order by id
 * @param {ObjectId} id
 * @returns {Promise<ProductionOrder>}
 */
export const getProductionOrderById = async (id) => {
  return ProductionOrder.findById(id)
    .populate({
      path: 'articles',
      populate: {
        path: 'machineId',
        select: 'machineCode machineNumber model floor status capacityPerShift capacityPerDay assignedSupervisor'
      }
    })
    .populate('createdBy', 'name email')
    .populate('lastModifiedBy', 'name email');
};

/**
 * Update production order by id
 * @param {ObjectId} orderId
 * @param {Object} updateBody
 * @returns {Promise<ProductionOrder>}
 */
export const updateProductionOrderById = async (orderId, updateBody) => {
  const order = await getProductionOrderById(orderId);
  if (!order) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Production order not found');
  }

  // Check if order number is being changed and if it's unique
  if (updateBody.orderNumber && updateBody.orderNumber !== order.orderNumber) {
    if (await ProductionOrder.findOne({ orderNumber: updateBody.orderNumber, _id: { $ne: orderId } })) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'Order number already taken');
    }
  }

  // Store previous values for logging
  const previousValues = {
    priority: order.priority,
    status: order.status,
    orderNote: order.orderNote,
    articles: order.articles.map(article => article._id || article)
  };

  // Handle articles update separately
  if (updateBody.articles && Array.isArray(updateBody.articles)) {
    // If articles are provided as objects with IDs, we need to find the actual Article documents
    const articleIds = [];
    
    for (const articleData of updateBody.articles) {
      let articleId = null;
      let articleDoc = null;
      
      // Determine article ID
      if (typeof articleData === 'string') {
        articleId = articleData;
      } else if (articleData && articleData.id) {
        articleId = articleData.id;
      } else if (articleData && articleData._id) {
        articleId = articleData._id;
      }
      
      // If no ID found but we have article data, create a new article
      if (!articleId && typeof articleData === 'object' && articleData !== null && articleData.articleNumber) {
        console.log(`Creating new article for articleNumber: ${articleData.articleNumber}`);
        
        // Validate product processes before creating article
        const articleNumber = articleData.articleNumber;
        const product = await Product.findOne({ factoryCode: articleNumber })
          .populate('processes.processId');

        if (!product) {
          throw new ApiError(
            httpStatus.BAD_REQUEST,
            `Article ${articleNumber}: Product not found with factoryCode "${articleNumber}". ` +
            `Please ensure the product exists with matching factoryCode.`
          );
        }

        const validation = validateProductProcesses(product.processes, articleNumber);
        
        if (!validation.valid) {
          throw new ApiError(
            httpStatus.BAD_REQUEST,
            `Cannot create article ${articleNumber}: Process validation failed.\n${validation.errors.join('\n')}`
          );
        }
        
        const currentUserId = updateBody.lastModifiedBy || order.lastModifiedBy || 'system';
        
        const newArticle = new Article({
          id: `ART${Date.now()}${Math.random().toString(36).substr(2, 9).toUpperCase()}`,
          orderId: order._id,
          articleNumber: articleData.articleNumber,
          articleName: articleData.articleName || '',
          plannedQuantity: articleData.plannedQuantity || 0,
          linkingType: articleData.linkingType || 'Manual Linking',
          priority: articleData.priority || 'Medium',
          remarks: articleData.remarks || '',
          machineId: articleData.machineId || null,
          color: articleData.color || '',
          size: articleData.size || '',
          unit: articleData.unit || 'PCS',
          createdBy: currentUserId,
          lastModifiedBy: currentUserId
        });
        
        articleDoc = await newArticle.save();
        console.log(`Created new article: ${articleDoc._id} (${articleDoc.articleNumber})`);
        articleIds.push(articleDoc._id);
      } else if (articleId) {
        console.log(`Looking for article with ID: ${articleId}`);
        
        // Check if it's a valid MongoDB ObjectId (24 hex characters)
        if (mongoose.Types.ObjectId.isValid(articleId) && articleId.length === 24) {
          articleDoc = await Article.findById(articleId);
        } else {
          // If it's a custom ID (like ARTMFDVOOJCLKC), find the article by its custom id field
          articleDoc = await Article.findOne({ id: articleId });
        }
        
        if (articleDoc) {
          console.log(`Found article: ${articleDoc._id} (${articleDoc.articleNumber})`);
          
          // Update article data if provided
          if (typeof articleData === 'object' && articleData !== null) {
            const updateFields = {};
            
            // Update allowed fields
            if (articleData.articleNumber !== undefined) updateFields.articleNumber = articleData.articleNumber;
            if (articleData.plannedQuantity !== undefined) updateFields.plannedQuantity = articleData.plannedQuantity;
            if (articleData.linkingType !== undefined) updateFields.linkingType = articleData.linkingType;
            if (articleData.priority !== undefined) updateFields.priority = articleData.priority;
            if (articleData.remarks !== undefined) updateFields.remarks = articleData.remarks;
            if (articleData.machineId !== undefined) updateFields.machineId = articleData.machineId;
            
            // Apply updates
            Object.assign(articleDoc, updateFields);
            await articleDoc.save();
          }
          
          articleIds.push(articleDoc._id);
        } else {
          console.warn(`Article with ID ${articleId} not found`);
          
          // If article doesn't exist but we have article data, create a new one
          if (typeof articleData === 'object' && articleData !== null && articleData.articleNumber) {
            console.log(`Creating new article for ID: ${articleId}`);
            
            // Validate product processes before creating article
            const articleNumber = articleData.articleNumber;
            const product = await Product.findOne({ factoryCode: articleNumber })
              .populate('processes.processId');

            if (!product) {
              throw new ApiError(
                httpStatus.BAD_REQUEST,
                `Article ${articleNumber}: Product not found with factoryCode "${articleNumber}". ` +
                `Please ensure the product exists with matching factoryCode.`
              );
            }

            const validation = validateProductProcesses(product.processes, articleNumber);
            
            if (!validation.valid) {
              throw new ApiError(
                httpStatus.BAD_REQUEST,
                `Cannot create article ${articleNumber}: Process validation failed.\n${validation.errors.join('\n')}`
              );
            }
            
            const currentUserId = updateBody.lastModifiedBy || order.lastModifiedBy || 'system';
            
            const newArticle = new Article({
              id: articleId,
              orderId: order._id,
              articleNumber: articleData.articleNumber,
              articleName: articleData.articleName || '',
              plannedQuantity: articleData.plannedQuantity || 0,
              linkingType: articleData.linkingType || 'Manual Linking',
              priority: articleData.priority || 'Medium',
              remarks: articleData.remarks || '',
              machineId: articleData.machineId || null,
              color: articleData.color || '',
              size: articleData.size || '',
              unit: articleData.unit || 'PCS',
              createdBy: currentUserId,
              lastModifiedBy: currentUserId
            });
            
            articleDoc = await newArticle.save();
            console.log(`Created new article: ${articleDoc._id} (${articleDoc.articleNumber})`);
            articleIds.push(articleDoc._id);
          }
        }
      }
    }
    
    // Update the order's articles array with the processed article IDs
    console.log(`Final articleIds array: ${JSON.stringify(articleIds)}`);
    order.articles = articleIds;
  }

  // Update other fields
  const fieldsToUpdate = { ...updateBody };
  delete fieldsToUpdate.articles; // Handle articles separately

  Object.assign(order, fieldsToUpdate);

  await order.save();

  // Create update log
  await createArticleLog({
    orderId: order._id.toString(),
    action: 'Order Updated',
    quantity: 0,
    remarks: `Order ${order.orderNumber} updated`,
    previousValue: JSON.stringify(previousValues),
    newValue: JSON.stringify(updateBody),
    changeReason: 'Order modification',
    userId: updateBody.lastModifiedBy || order.lastModifiedBy || 'system',
    floorSupervisorId: updateBody.lastModifiedBy || order.lastModifiedBy || 'system'
  });

  // Return populated order with articles and machine data
  return order.populate({
    path: 'articles',
    populate: {
      path: 'machineId',
      select: 'machineCode machineNumber model floor status capacityPerShift capacityPerDay assignedSupervisor'
    }
  });
};

/**
 * Delete production order by id
 * @param {ObjectId} orderId
 * @returns {Promise<ProductionOrder>}
 */
export const deleteProductionOrderById = async (orderId) => {
  const order = await getProductionOrderById(orderId);
  if (!order) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Production order not found');
  }

  // Allow deletion of orders regardless of status

  // Delete all articles and their logs
  for (const article of order.articles) {
    const articleId = article._id || article; // Handle both populated and non-populated articles
    await ArticleLog.deleteMany({ articleId: articleId.toString() });
    await Article.findByIdAndDelete(articleId);
  }

  // Delete order logs
  await ArticleLog.deleteMany({ orderId: orderId.toString() });

  // Delete the order
  await order.deleteOne();

  return order;
};

/**
 * Get orders by floor
 * @param {string} floor
 * @param {Object} filter
 * @param {Object} options
 * @returns {Promise<QueryResult>}
 */
export const getOrdersByFloor = async (floor, filter, options) => {
  // Use comprehensive floor order for visibility logic
  const floorOrder = getAllFloorsOrder();

  // Map URL-friendly floor names to proper enum values
  const floorMapping = {
    'FinalChecking': 'Final Checking',
    'FinalChecking': 'Final Checking',
    'finalchecking': 'Final Checking',
    'final-checking': 'Final Checking',
    'final_checking': 'Final Checking',
    'SecondaryChecking': 'Secondary Checking',
    'secondarychecking': 'Secondary Checking',
    'secondary-checking': 'Secondary Checking',
    'secondary_checking': 'Secondary Checking',
    'Silicon': 'Silicon',
    'silicon': 'Silicon'
  };

  // Convert floor name if needed
  const normalizedFloor = floorMapping[floor] || floor;

  const requestedFloorIndex = floorOrder.indexOf(normalizedFloor);
  if (requestedFloorIndex === -1) {
    throw new ApiError(httpStatus.BAD_REQUEST, `Invalid floor: ${floor}`);
  }

  // Build complex query for floor visibility
  const floorKey = getFloorKey(normalizedFloor);
  
  // Handle machineId filter separately if provided
  let machineFilter = {};
  let originalMachineId = null;
  if (filter.machineId) {
    originalMachineId = filter.machineId;
    machineFilter = { 'articles.machineId': filter.machineId };
    delete filter.machineId; // Remove from main filter to avoid conflicts
  }
  
  const floorFilter = {
    ...filter,
    ...machineFilter,
    $or: [
      // 1. Orders currently on this floor
      { currentFloor: normalizedFloor },
      // 2. Orders on previous floors (if entire order not completed)
      {
        currentFloor: { $in: floorOrder.slice(0, requestedFloorIndex) },
        status: { $ne: 'Completed' }
      },
      // 3. Orders that have work on this floor (received quantity > 0)
      {
        [`articles.floorQuantities.${floorKey}.received`]: { $gt: 0 }
      }
    ]
  };

  // Get orders with basic populate first
  const orders = await ProductionOrder.paginate(floorFilter, {
    ...options,
    populate: {
      path: 'articles',
      populate: {
        path: 'machineId',
        select: 'machineCode machineNumber model floor status capacityPerShift capacityPerDay assignedSupervisor'
      }
    }
  });

  // Post-process to filter out orders and articles that shouldn't be visible on this floor
  const filteredResults = orders.results.filter(order => {
    // Check if order should be visible on this floor
    if (!shouldOrderBeVisibleOnFloor(order, normalizedFloor, floorOrder)) {
      return false;
    }
    
    // Filter articles within the order
    if (order.articles && order.articles.length > 0) {
      order.articles = order.articles.filter(article => {
        // Check machineId filter if provided
        if (originalMachineId && article.machineId?.toString() !== originalMachineId) {
          return false;
        }
        return shouldArticleBeVisibleOnFloor(article, normalizedFloor, floorOrder);
      });
    }
    
    return true;
  });

  return {
    ...orders,
    results: filteredResults,
    totalResults: filteredResults.length,
    totalPages: Math.ceil(filteredResults.length / (options.limit || 10))
  };
};

/**
 * Check if an order should be visible on a specific floor
 * @param {Object} order - Production order
 * @param {string} floor - Requested floor
 * @param {Array} floorOrder - Array of floors in order
 * @returns {boolean}
 */
const shouldOrderBeVisibleOnFloor = (order, floor, floorOrder) => {
  const requestedFloorIndex = floorOrder.indexOf(floor);
  const currentFloorIndex = floorOrder.indexOf(order.currentFloor);

  // 1. Always show if order is currently on this floor
  if (order.currentFloor === floor) {
    return true;
  }

  // 2. Show if order is on a previous floor and not completed
  if (currentFloorIndex < requestedFloorIndex && order.status !== 'Completed') {
    return true;
  }

  // 3. Show if any article has work on this floor
  if (order.articles && order.articles.length > 0) {
    const floorKey = getFloorKey(floor);
    
    for (const article of order.articles) {
      const floorData = article.floorQuantities[floorKey];
      if (floorData && floorData.received > 0) {
        return true;
      }
    }
  }

  return false;
};

/**
 * Check if an article should be visible on a specific floor
 * @param {Object} article - Article object
 * @param {string} floor - Requested floor
 * @param {Array} floorOrder - Array of floors in order
 * @returns {boolean}
 */
const shouldArticleBeVisibleOnFloor = (article, floor, floorOrder) => {
  const requestedFloorIndex = floorOrder.indexOf(floor);
  const currentFloorIndex = floorOrder.indexOf(article.currentFloor);

  // 1. Always show if article is currently on this floor
  if (article.currentFloor === floor) {
    return true;
  }

  // 2. Show if article is on a previous floor and not completed
  if (currentFloorIndex < requestedFloorIndex && article.status !== 'Completed') {
    return true;
  }

  // 3. Show if article has work on this floor
  const floorKey = getFloorKey(floor);
  const floorData = article.floorQuantities[floorKey];
  if (floorData && floorData.received > 0) {
    return true;
  }

  return false;
};

// getFloorKey function is now imported from productionHelper.js

/**
 * Bulk create orders
 * @param {Array} orders - Array of order objects
 * @param {number} batchSize - Number of orders to process in each batch
 * @param {Object} user - Current user from request
 * @returns {Promise<Object>}
 */
export const bulkCreateOrders = async (orders, batchSize = 50, user = null) => {
  const results = {
    total: orders.length,
    created: 0,
    failed: 0,
    errors: [],
    processingTime: 0,
  };

  const startTime = Date.now();

  try {
    // Process orders in batches
    for (let i = 0; i < orders.length; i += batchSize) {
      const batch = orders.slice(i, i + batchSize);
      
      const batchPromises = batch.map(async (orderData, batchIndex) => {
        const globalIndex = i + batchIndex;
        
        try {
          // Order number will be auto-generated by the model
          // Remove orderNumber from orderData to let the model handle it
          delete orderData.orderNumber;

          // Create the order
          const order = await createProductionOrder(orderData, user);
          results.created++;
          
        } catch (error) {
          results.failed++;
          results.errors.push({
            index: globalIndex,
            orderNumber: orderData.orderNumber || `Order ${globalIndex + 1}`,
            error: error.message,
          });
        }
      });

      await Promise.all(batchPromises);
      
      // Add delay between batches
      if (i + batchSize < orders.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    results.processingTime = Date.now() - startTime;
    console.log(`Bulk order creation completed in ${results.processingTime}ms: ${results.created} created, ${results.failed} failed`);

  } catch (error) {
    results.processingTime = Date.now() - startTime;
    throw new ApiError(httpStatus.BAD_REQUEST, error.message);
  }

  return results;
};

/**
 * Create article log helper function
 * @param {Object} logData
 * @returns {Promise<ArticleLog>}
 */
const createArticleLog = async (logData) => {
  const log = new ArticleLog({
    id: `LOG-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    ...logData,
    date: new Date().toISOString().split('T')[0],
    timestamp: new Date().toISOString()
  });
  
  return log.save();
};
